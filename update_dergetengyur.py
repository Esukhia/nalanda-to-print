import re
from pathlib import Path

from formatted_dmp import FormattedDMP


def get_pages(filename):
    content = filename.read_text()
    pages = re.split(r"(\[[a-z0-9]+\]\n)", content)
    return pages


def is_notemark_diff(diff):
    op, text = diff
    return '#' in text


def match_notemark(text):
    regex = r'(#)'
    match = re.findall(regex, text)
    return match[0] if match else None


def expand_diffs(diffs):
    expanded = []
    for op, string in diffs:
        if string.count('#') > 1:
            parts = re.split(r'(#)', string)
            for p in parts:
                if p:
                    expanded.append((op, p))
        else:
            expanded.append((op, string))

    return expanded


def clean_patches(orig_patches, is_needed_diff, find_needed):
    """
    Selects and cleans a given patch list using functions given as arguments
    Intended for patches generated by Google's diff_match_patch module.

    :param orig_patches: original set of patches
    :type orig_patches: patch objects created with DMP.patch_make(str, str)
    :param is_needed_diff: test to see if a diff contains a wanted modification
    :type is_needed_diff: funct returning a boolean
    :param find_needed: finds the parts of the diff that are to keep
    :type find_needed: funct returning the replacement str
    :return: filtered set of patches that only contain the needed modifications
    """
    new_patches = []
    for patch in orig_patches:
        keep = False
        new_diffs = []
        expanded_diffs = expand_diffs(patch.diffs)
        for diff in expanded_diffs:

            # Important: keep the diffs with no modification used as context
            # (used by DMP to calculate the correct patching location)
            if diff[0] == 0:
                new_diffs.append(diff)

            # find diff to modify
            elif is_needed_diff(diff):
                op, text = diff
                needed = find_needed(text)
                if needed:
                    new_diffs.append((op, needed))
                    keep = True

        # select only relevant patches
        if keep:
            patch.diffs = new_diffs  # replace the old diffs with the modified ones
            new_patches.append(patch)

    return new_patches


def update_vol(volname, orig, modif):
    updated = []
    pages_orig = get_pages(orig / volname)
    pages_modif = get_pages(modif / volname)
    assert len(pages_orig) == len(pages_modif)
    for page_o, page_m in zip(pages_orig, pages_modif):
        page_m = page_m.replace('#', '')
        if page_o and page_m and page_o != page_m:
            patches = dmp.patch_make(page_m, page_o)
            patches = clean_patches(patches, is_notemark_diff, match_notemark)
            new_page, res = dmp.patch_apply(patches, page_m)
            try:
                assert page_o.count('#') == new_page.count('#')
            except AssertionError:
                print('ok')
            updated.append(new_page)
        else:
            updated.append(page_m)

    updated = ''.join(updated)
    return updated


def update_tengyur(orig, modif):
    orig, modif = Path(orig), Path(modif)
    pb_vols = ['170_', '171_', '208_', '211_']
    volumes = [f.name for f in orig.glob('*.txt') if not f.name[:4] in pb_vols]
    for v in sorted(volumes):
        print(v)
        updated = update_vol(v, orig, modif)
        Path(Path('updated_derge-tengyur-tags') / v).write_text(updated)


def get_rabten_modifs(orig, modif):
    orig, modif = Path(orig), Path(modif)
    pb_vols = ['073']
    volumes = [f.name for f in orig.glob('*.txt') if f.name[:3] not in pb_vols]
    diffs = {}
    for v in sorted(volumes):
        print(v)
        lines_orig = Path(orig / v).open().readlines()
        lines_new = Path(modif / v).open().readlines()
        assert len(lines_orig) == len(lines_new)
        for line_o, line_m in zip(lines_orig, lines_new):
            line_o = line_o.replace('#', '')
            line_m = line_m.replace('#', '')
            if line_o and line_m and line_o != line_m:
                patches = dmp.patch_make(line_o, line_m)
                applied, res = dmp.patch_apply(patches, line_o, mode='CM')
                assert False not in res
                vol = v.replace('.txt', '')
                if vol not in diffs:
                    diffs[vol] = []
                diffs[vol].append(applied)
    out = []
    for k, v in diffs.items():
        for u in v:
            out.append(f'{k},{u.strip()}')
    out = '\n'.join(out)
    Path('modifs.csv').write_text(out)


if __name__ == '__main__':

    tengyur_new_hashes = 'derge-tengyur-tags'
    tengyur_old_hashes = '/tmp/derge-tengyur-tags'

    dmp = FormattedDMP()
    dmp.Diff_Timeout = 0

    get_rabten_modifs(tengyur_old_hashes, tengyur_new_hashes)
    # update_tengyur(tengyur_new_hashes, tengyur_old_hashes)
